#! /usr/bin/env python3
# -*- coding: utf8 -*-

##########################################################################
#                                                                        #
# Program: va.py   Version 1.1              Date: 05/08/2017             #
#                                                                        #
# A varied set of tools to analyse vibrational modes in terms of         #
# localized internal coordinates.                                        #
#                                                                        #
# (c) Filipe Teixeira, 2017                                              #
#                                                                        #
##########################################################################

import numpy as np
import sys
import sklearn.linear_model as sklm
import sklearn.metrics as skmt

# General Options
Opts={}
Opts['isLinear']=False
Opts['isTState']=False
Opts['cut']='auto'
Opts['cutval']=0.1
Opts['delta']=0.2
Opts['tol']=0.2
Opts['doOuts']=True
Opts['doTors']=True
Opts['doMW']=True
Opts['doPure']=False
Opts['pureEngine']='Imp'
Opts['doAutoSel']=False
Opts['doICC']=False
Opts['doNMP']=False
Opts['doLD']=False
Opts['doARD']=True
Opts['input']='OrcaHess'
Opts['aniMode']=[]
Opts['anic']=[]

Linear=False
Transition=False

# General Data
Bohr2Ang=0.529

Symbols=['h','he','li','be','b','c','n','o','f','ne','na','mg','al','si','p','s','cl','ar','k','ca','sc','ti','v','cr','mn','fe','co','ni','cu','zn','ga','ge','as','se','br','kr','rb', 'sr', 'y', 'zr', 'nb', 'mo', 'tc', 'ru', 'rh', 'pd', 'ag', 'cd', 'in', 'sn', 'sb', 'te', 'i', 'xe', 'cs', 'ba', 'la', 'ce', 'pr', 'nd', 'pm', 'sm', 'eu', 'gd', 'tb', 'dy', 'ho', 'er', 'tm', 'yb', 'lu', 'hf', 'ta', 'w', 're', 'os', 'ir', 'pt', 'au', 'hg', 'tl', 'pb', 'bi']

Masses=[1.007825, 4.002602, 6.94, 9.0121831, 10.81, 12.0000, 14.007, 15.9949159, 18.998403163, 20.1797, 22.98976928, 24.305, 26.9815385, 28.085, 30.973761998, 32.06, 35.45, 39.948, 39.0983, 40.078, 44.955908, 47.867, 50.9415, 51.9961, 54.938044, 55.845, 58.933194, 58.6934, 63.546, 65.38, 69.723, 72.63, 74.921595, 78.971, 79.904, 83.798, 85.4678, 87.62, 88.90584, 91.224, 92.90637, 95.95, 97, 101.07, 102.9055, 106.42, 107.8682, 112.414, 114.818, 118.71, 121.76, 127.6, 126.90447, 131.293, 132.90545196, 137.327, 138.90547, 140.116, 140.90766, 144.242, 145, 150.36, 151.964, 157.25, 158.92535, 162.5, 164.93033, 167.259, 168.93422, 173.054, 174.9668, 178.49, 180.94788, 183.84, 186.207, 190.23, 192.217, 195.084, 196.966569, 200.592, 204.38, 207.2, 208.9804]

Raddi=[ 0.5, 0.3, 1.7, 1.1, 0.9, 0.7, 0.6, 0.6, 0.5, 0.4, 1.9, 1.5, 1.2, 1.1, 1.0, 0.9, 0.8, 0.7, 2.4, 1.9, 1.8, 1.8, 1.7, 1.7, 1.6, 1.6, 1.5, 1.5, 1.5, 1.4, 1.4, 1.3, 1.1, 1.0, 0.9, 0.9, 2.7, 2.2, 2.1, 2.1, 2.0, 1.9, 1.8, 1.8, 1.7, 1.7, 1.7, 1.6, 1.6, 1.5, 1.3, 1.2, 1.2, 1.1, 3.0, 2.5, 2.0, 2.0, 2.5, 2.1, 2.1, 2.4, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.2, 2.2, 2.2, 2.1, 2.0, 1.9, 1.9, 1.9, 1.8, 1.8, 1.7, 1.7, 1.6, 1.5, 1.4]

## Support Functions ##

def animateMode(tfn,symb,geo,m,nsteps=50,damp=0.33):
	"""displaces geo over vector m and punches a xyz file tfn"""
	natoms=len(symb)
	tf=open(tfn,'w')
	v=damp*np.sin(np.linspace(0-0,2.0*np.pi,nsteps))
	for n in range(nsteps):
		g=geo.copy()
		g = g.reshape(g.size)+(v[n]*m)
		tf.write(" %d \n Generated by vibAnalysis d=%7.4f\n"%(natoms,v[n]))
		for i in range(natoms):
			tf.write(" %3s %10.6f %10.6f %10.6f\n"%(symb[i],g[3*i],g[(3*i)+1],g[(3*i)+2]))
	tf.close()


def readHess(ifn):
	"""Opens Orca Hess file ifn and returns:
	- symbols as list
	- geometry as np.array (in angs)
	- masses as np.array
	- freqs as np.array
	- normal mode displacements as np.array (normalized) 
	- IR Intensities as np.array
	- Raman Intensities as np.array
	Depending on Linear and Transition, freqs and modes will be
	pruned out of the translational and rotational components."""
	f=open(ifn,'r')
	data=f.readlines()
	f.close()
	# read masses, geometry and atomic symbols
	for i in range(len(data)):
		if ('$atoms' in data [i]):
			natoms=int(data[i+1])
			ipos=i+2
			break
	mass=np.zeros(natoms)
	geo=np.zeros((natoms,3))
	p=0
	symbols=[]
	for i in range(ipos,ipos+natoms):
		l=data[i].split()[2:]
		mass[p]=float(data[i].split()[1])
		symbols.append(data[i].split()[0].lower())
		geo[p,:]=list(map(float,l))
		p+=1
	# read frequency list
	for i in range(len(data)):
		if ('$vibrational_frequencies' in data [i]):
			nfreqs=int(data[i+1])
			ipos=i+2
			break
	freqs=np.zeros(nfreqs)
	p=0
	for i in range(ipos,ipos+nfreqs):
		freqs[p]=float(data[i].split()[1])
		p+=1
	# read normal mode displacements
	for i in range(len(data)):
		if ('$normal_modes' in data [i]):
			ndegs=int(data[i+1].split()[0])
			ipos=i+2
			break
	modes=np.zeros((ndegs,ndegs))
	nils=int(ndegs/6)
	nrem=np.mod(ndegs,6)
	#epos=ipos+((ndegs+1)*nils)+1 #old versions of Orca?
	epos=ipos+((ndegs+1)*nils)
	if (nrem>0): epos+= (ndegs+1)
	icol=0
	ecol=0
	nread=0
	for n in range(ipos,epos,ndegs+1):
		icol=ecol
		ecol=icol+6
		nread+=1
		if (nread>nils): ecol=ndegs+1
		l=0
		for i in range(n+1,n+ndegs+1):
			line=data[i].split()[1:]
			modes[l,icol:ecol]=line
			l+=1
	# read IR intensities
	irInt=np.zeros(nfreqs)
	found=False
	for i in range(len(data)):
		if ('$ir_spectrum' in data [i]):
			nfreqs=int(data[i+1])
			ipos=i+2
			found=True
			break
	if(found):
		p=0
		for i in range(ipos,ipos+nfreqs):
			irInt[p]=float(data[i].split()[1])
			p+=1
	else:
		print("Warnning: IR intensities not found.")
	# read Raman intensities
	raInt=np.zeros(nfreqs)
	found=False
	for i in range(len(data)):
		if ('$raman_spectrum' in data [i]):
			nfreqs=int(data[i+1])
			ipos=i+2
			found=True
			break
	if(found):
		p=0
		for i in range(ipos,ipos+nfreqs):
			raInt[p]=float(data[i].split()[1])
			p+=1
	else:
		print("Warnning: Raman intensities not found.")
	# prune rotational and translational modes from freqs, modes, and Ints
	idx=list(range(nfreqs))
	if(Linear and Transition):
		idx=[0]+list(range(6,nfreqs))
	elif(Linear and not Transition):
		idx=list(range(5,nfreqs))
	elif(not Linear and Transition):
		idx=[0]+list(range(7,nfreqs))
	else:
		idx=list(range(6,nfreqs))
	freqs=freqs[idx]
	irInt=irInt[idx]
	raInt=raInt[idx]
	modes=modes[:,idx]
	# convert geo to angs
	geo = geo*Bohr2Ang
	# normalize normal modes
	for i in range(np.shape(modes)[1]):
		modes[:,i]=modes[:,i]/np.linalg.norm(modes[:,i])
	return(symbols,geo,mass,freqs,modes,irInt,raInt)

def readG09out(ifn):
	"""Opens Orca Hess file ifn and returns:
	- symbols as list
	- geometry as np.array (in angs)
	- masses as np.array
	- freqs as np.array
	- normal mode displacements as np.array (normalized) 
	- IR Intensities as np.array
	- Raman Intensities as np.array
	Depending on Linear and Transition, freqs and modes will be
	pruned out of the translational and rotational components."""
	f=open(ifn,'r')
	data=f.readlines()
	f.close()
	# get number of atoms
	natoms=-1
	for i in range(len(data)):
		if('NAtoms=' in data[i]):
			#print(data[i][8:14])
			natoms=int(data[i][8:14])
			break
	symbols=[]
	mass=np.zeros(natoms)
	geo=np.zeros((natoms,3))
	p=0
	#read (last) geometry in standard orientation
	istart=-1
	for i in range(len(data)):
		if('Standard orientation:' in data[i]):
			istart=i+5
	if(istart>0):
		for i in range(istart,istart+natoms):
			#print(data[i])
			l=data[i].split()
			#symbols.append(Symbols[int(l[1])-1].capitalize())
			symbols.append(Symbols[int(l[1])-1])
			geo[p,:]=np.array(list(map(float,l[3:6])))
			mass[p]=Masses[int(l[1])-1]
			p += 1
		#print(symbols)
		#print(geomass
		#print(mass)
	else:	
		print("ERROR: Cannot read geometry!\n")
		sys.exit(1)
	# read vibrational frequencies, modes, IR and Raman Intensities
	nfreqs=0
	freqs=[]
	irInt=[]
	raInt=[]
	modes=np.zeros((3*natoms,0))
	for i in range(len(data)):
		mstart=-1
		if('Frequencies -- ' in data[i]):
			l=data[i].split()[2:]
			freqsInRow=len(l)
			for f in l:
				freqs.append(float(f))
			for j in range(i+1,i+9):
				if('Atom' in data[j]):
					mstart=j+1
					break
				if('IR Inten    --' in data[j]):
					l=data[j].split()[3:]
					for f in l:
						irInt.append(float(f))
				if('Raman Activ --' in data[j]):
					l=data[j].split()[3:]
					for f in l:
						raInt.append(float(f))
			lmodes=[]
			for k in range(freqsInRow):
				lmodes.append([])
			for j in range(mstart,mstart+natoms):
				p=0
				l=list(map(float,data[j].split()[2:]))
				#print(l)
				for k in range(freqsInRow):
					#print(k, p, l[k+p])
					lmodes[k].append(l[k+p]) #dx
					p += 1
					#print(k, p, l[k+p])
					lmodes[k].append(l[k+p]) #dy
					p += 1
					#print(k, p, l[k+p])
					lmodes[k].append(l[k+p]) #dz
			lmodes=np.transpose(np.array(lmodes))
			modes=np.concatenate((modes,lmodes),axis=1)
	if(len(irInt)==0):
		print("Warnning: IR intensities not found.")
		irInt=np.zeros(len(freqs))
	if(len(raInt)==0):
		print("Warnning: Raman intensities not found.")
		raInt=np.zeros(len(freqs))
	# normalize normal modes
	for i in range(np.shape(modes)[1]):
		modes[:,i]=modes[:,i]/np.linalg.norm(modes[:,i])
	return(symbols,geo,mass,freqs,modes,irInt,raInt)

def readUserIC(fn):
	"""Reads additional internal coordinates defined by the user"""
	o=[]
	f=open(fn,'r')
	udata=f.readlines()
	f.close()
	for line in udata:
		if('#' in line):
			continue
		elif(line.strip()==''):
			continue
		else:
			l=line.split()
			if(l[0].upper()=='B'):
				o.append([1,int(l[1])-1,int(l[2])-1])
			elif(l[0].upper()=='A'):
				o.append([2,int(l[1])-1,int(l[2])-1,int(l[3])-1])
			elif(l[0].upper()=='O'):
				o.append([3,int(l[1])-1,int(l[2])-1,int(l[3])-1,int(l[4])-1])
			elif(l[0].upper()=='T'):
				o.append([4,int(l[1])-1,int(l[2])-1,int(l[3])-1,int(l[4])-1])
			else:
				continue
	return(o)

def makeS(symb,geo,useric=[]):
	"""Automatically identifies internal coordinates using 
	connectivity deduced from covalent radii and generates
	Wilson's S matrix for the specified geometry"""
	## Parameters from Global Opts
	delta=Opts['delta']
	tol=Opts['tol']
	coords=[] # each coord is a tuple of 5 ints: coord type + 4 atom idxs
	natoms=np.shape(geo)[0]
	ageo=np.reshape(geo.copy(),(np.size(geo),1))
	# temporary lists
	valence=[] #store number of bonds for each atom
	centred=[] #store number angles this atoms is the centre of
	coordination=[]
	for i in range(natoms):
		coordination.append([])
		valence.append(0)
		centred.append(0)
	bonds=[]
	angles=[]
	dihedrals=[]
	bondsL=[]
	anglesA=[]
	dihedralsA=[]
	outs=[]
	outsA=[]
	# add user-defined ICs
	if(useric!=[]):
		for i in range(len(useric)):
			if(useric[i][0]==1):
				bonds.append(useric[i][1:])
				valence[useric[i][1]] += 1
				valence[useric[i][2]] += 1
				coordination[useric[i][1]].append(useric[i][2])
				coordination[useric[i][2]].append(useric[i][1])
			elif(useric[i][0]==2):
				angles.append(useric[i][1:])
			elif(useric[i][0]==3):
				outs.append(useric[i][1:])
			elif(useric[i][0]==4):
				dihedrals.append(useric[i][1:])
	# search for bonds
	for i in range(np.size(geo,0)):
		r1=Raddi[Symbols.index(symb[i])]
		for j in range(i+1,np.size(geo,0)):
			rl=(1.0+tol)*(r1+Raddi[Symbols.index(symb[j])])
			#print("%d %d %f %f"%(i,j,rl,np.linalg.norm(geo[i]-geo[j])))
			if ((np.linalg.norm(geo[i]-geo[j])<rl)and([i,j] not in bonds)):
				bonds.append([i,j])
				valence[i] += 1
				valence[j] += 1
				coordination[i].append(j)
				coordination[j].append(i)
	#find triatomic angles between atomic bonds
	for i in range(len(bonds)):
		set1=set(bonds[i])
		for j in range(i+1,len(bonds)):
			set2=set(bonds[j])
			if (len(set1&set2)==1):
				tmp=list(set1^set2)
				tmp.sort()
				common=list(set1&set2)[0]
				candidate=[tmp[0],common,tmp[1]]
				centred[common] += 1
				if(Opts["doAutoSel"]):
					if((candidate not in angles)and(centred[common]<valence[common])):
						angles.append(candidate)
				else:
					if(candidate not in angles):
						angles.append(candidate)
	#find dihedrals (torsions) and out-of-plane (outs)
	for i in range(len(angles)):
		set1=set(angles[i])
		for j in range(i+1,len(angles)):
			set2=set(angles[j])
			if (len(set1&set2)==2):
				tmp=list(set1^set2) # non-common atoms
				tmp2=list(set1&set2)# common atoms
				if(angles[i][1]==angles[j][1]): # out-of-plane 
					a2=angles[i][1] #reference
					tmplst=tmp+tmp2
					tmplst.pop(tmplst.index(a2)) #remove the common
					tmplst.sort()
					a1=tmplst[0]
					a3=tmplst[1]
					a4=tmplst[2]
					if(Opts['doOuts']):
						if([a1,a2,a3,a4] not in outs):
							outs.append([a1,a2,a3,a4])
				# now the torsions
				else:
					candidate=[]
					if((angles[i][1]==angles[j][0])and(angles[j][1]==angles[i][0])):
						candidate=[angles[i][2],angles[i][1],angles[j][1],angles[j][2]]
					elif((angles[i][1]==angles[j][0])and(angles[j][1]==angles[i][2])):
						candidate=[angles[i][0],angles[i][1],angles[j][1],angles[j][2]]
					elif((angles[i][1]==angles[j][2])and(angles[j][1]==angles[i][0])):
						candidate=[angles[i][2],angles[i][1],angles[j][1],angles[j][0]]
					elif((angles[i][1]==angles[j][2])and(angles[j][1]==angles[i][2])):
						candidate=[angles[i][0],angles[i][1],angles[j][1],angles[j][0]]
					if(Opts["doAutoSel"]):
						if((candidate!=[])and(candidate[1:]not in [h[1:] for h in dihedrals])):
							if(Opts['doTors']):
								dihedrals.append(candidate)
					else:
						if(candidate!=[]):
							if(Opts['doTors']):
								dihedrals.append(candidate)
	#calc S for bonds
	S=np.zeros((np.size(geo),len(bonds)+len(angles)+len(dihedrals)+len(outs)))
	n=0
	for i in range(len(bonds)):
		coords.append([1]+bonds[i]+[0,0])
		sb=np.zeros(np.shape(geo))
		b0=np.linalg.norm(geo[bonds[i][0]]-geo[bonds[i][1]])
		bondsL.append(b0)
		for j in range(np.size(geo,0)):
			for k in range(3):
				gp=np.copy(geo)
				gp[j,k]+=delta
				b1=np.linalg.norm(gp[bonds[i][0]]-gp[bonds[i][1]])
				sb[j,k]=(b1-b0)/delta
		S[:,n]=np.reshape(sb,(1,np.size(sb)))
		n+=1
	# calc S for angles
	for i in range(len(angles)):
		coords.append([2]+angles[i]+[0])
		sb=np.zeros(np.shape(geo))
		r01=geo[angles[i][0]]-geo[angles[i][1]]
		r21=geo[angles[i][2]]-geo[angles[i][1]]
		r01=r01/np.linalg.norm(r01)
		r21=r21/np.linalg.norm(r21)
		phi0=np.arccos(np.dot(r01,r21))
		anglesA.append(phi0*(180.0/np.pi))
		for j in [angles[i][1]]:
			for k in range(3):
				gp=np.copy(geo)
				gp[j,k]+=delta*(np.cos(phi0))**2
				r01p=gp[angles[i][0]]-gp[angles[i][1]]
				r21p=gp[angles[i][2]]-gp[angles[i][1]]
				r01p=r01p/np.linalg.norm(r01p)
				r21p=r21p/np.linalg.norm(r21p)
				phi1=np.arccos(np.dot(r01p,r21p))
				sb[j,k]=(phi1-phi0)/delta
		for j in [angles[i][0],angles[i][2]]:
			for k in range(3):
				gp=np.copy(geo)
				gp[j,k]+=delta*(np.sin(phi0))**2
				r01p=gp[angles[i][0]]-gp[angles[i][1]]
				r21p=gp[angles[i][2]]-gp[angles[i][1]]
				r01p=r01p/np.linalg.norm(r01p)
				r21p=r21p/np.linalg.norm(r21p)
				phi1=np.arccos(np.dot(r01p,r21p))
				sb[j,k]=(phi1-phi0)/delta
		S[:,n]=np.reshape(sb,(1,np.size(sb)))
		n+=1
	# calc S for outs
	for i in range(len(outs)):
		coords.append([3]+outs[i])
		sb=np.zeros(np.shape(geo))
		a1=outs[i][0]
		a2=outs[i][1]
		a3=outs[i][2]
		a4=outs[i][3]
		r1=geo[a1]-geo[a2]
		r2=geo[a3]-geo[a2]
		r3=geo[a4]-geo[a2]
		n1=np.cross(r1,r2)
		n2=np.cross(r3,r2)
		atmp=np.dot(n1,n2)/(np.linalg.norm(n1)*np.linalg.norm(n2))
		if(atmp>1.0):
			teta0=np.pi-np.arccos(1.0)
		elif(atmp<-1.0):
			teta0=np.pi-np.arccos(-1.0)
		else:
			teta0=np.pi-np.arccos(atmp)
		outsA.append(np.rad2deg(teta0))
		#for j in range(np.size(geo,0)):
		for j in [a4]: # a4 should define the angle between bond and plane
			for k in range(3):
				gp=np.copy(geo)
				gp[j,k]+=delta
				r1p=gp[a1]-gp[a2]
				r2p=gp[a3]-gp[a2]
				r3p=gp[a4]-gp[a2]
				n1p=np.cross(r1p,r2p)
				n2p=np.cross(r3p,r2p)
				atmp=np.dot(n1p,n2p)/(np.linalg.norm(n1p)*np.linalg.norm(n2p))
				if(atmp>1.0):
					teta1=np.pi-np.arccos(1.0)
				elif(atmp<-1.0):
					teta1=np.pi-np.arccos(-1.0)
				else:
					teta1=np.pi-np.arccos(atmp)
				sb[j,k]=(teta1-teta0)/delta
		S[:,n]=np.reshape(sb,(1,np.size(sb)))
		n+=1
	# calc S for torsions
	for i in range(len(dihedrals)):
		sb=np.zeros(np.shape(geo))
		a1=dihedrals[i][0]
		a2=dihedrals[i][1]
		a3=dihedrals[i][2]
		a4=dihedrals[i][3]
		r1=geo[a1]-geo[a2]
		r2=geo[a3]-geo[a2]
		r3=geo[a4]-geo[a3]
		r1 /= np.linalg.norm(r1)
		r2 /= np.linalg.norm(r2)
		r3 /= np.linalg.norm(r3)
		n1=np.cross(r1,r2)
		n2=np.cross(r3,r2)
		if(np.linalg.norm(n1)<1.0e-2):
			continue
		elif(np.linalg.norm(n2)<1.0e-2):
			continue
		n1 /= np.linalg.norm(n1)
		n2 /= np.linalg.norm(n2)
		atmp=np.dot(n1,n2)/(np.linalg.norm(n1)*np.linalg.norm(n2))
		if(atmp>1.0):
			teta0=np.arccos(1.0)
		elif(atmp<-1.0):
			teta0=np.arccos(-1.0)
		else:
			teta0=np.arccos(atmp)
		for j in [a1,a4]: # these two define the angle between the two planes
			for k in range(3):
				gp=np.copy(geo)
				gp[j,k]+= delta
				r1p=gp[a1]-gp[a2]
				r2p=gp[a2]-gp[a3]
				r3p=gp[a4]-gp[a3]
				r1p /= np.linalg.norm(r1p)
				r2p /= np.linalg.norm(r2p)
				r3p /= np.linalg.norm(r3p)
				n1p=np.cross(r1p,r2p)
				n2p=np.cross(r3p,r2p)
				n1p /= np.linalg.norm(n1p)
				n2p /= np.linalg.norm(n2p)
				atmp=np.dot(n1p,n2p)/(np.linalg.norm(n1p)*np.linalg.norm(n2p))
				if(atmp>1.0):
					teta1=np.arccos(1.0)
				elif(atmp<-1.0):
					teta1=np.arccos(-1.0)
				else:
					teta1=np.arccos(atmp)
				sb[j,k]=(teta1-teta0)/delta
		coords.append([4]+dihedrals[i])
		dihedralsA.append(np.rad2deg(teta0))
		S[:,n]=np.reshape(sb,(1,np.size(sb)))
		n+=1
	#normalise S
	S=S[:,0:n]
	#for i in range(n):
	#	S[:,i]=S[:,i]/np.linalg.norm(S[:,i])
	return(coords,S)

def modeStr(mode,symbs):
	"""returns a formated string describing mode"""
	o=""
	if(mode[0]==1): # bond
		o="BOND %s%d %s%d"%(symbs[mode[1]].capitalize(),mode[1]+1,symbs[mode[2]].capitalize(),mode[2]+1)
	elif(mode[0]==2): # ANGLE
		o="ANGLE %s%d %s%d %s%d"%(symbs[mode[1]].capitalize(),mode[1]+1,symbs[mode[2]].capitalize(),mode[2]+1,symbs[mode[3]].capitalize(),mode[3]+1)
	elif(mode[0]==3): # OUT OF PLANE
		o="OUT %s%d %s%d %s%d %s%d"%(symbs[mode[1]].capitalize(),mode[1]+1,symbs[mode[2]].capitalize(),mode[2]+1,symbs[mode[3]].capitalize(),mode[3]+1,symbs[mode[4]].capitalize(),mode[4]+1)
	elif(mode[0]==4): # TORSION
		o="TORSION %s%d %s%d %s%d %s%d"%(symbs[mode[1]].capitalize(),mode[1]+1,symbs[mode[2]].capitalize(),mode[2]+1,symbs[mode[3]].capitalize(),mode[3]+1,symbs[mode[4]].capitalize(),mode[4]+1)
	return(o)

def punchLIC(o,icl,symbs,geo):
	"""Punches a list of internal coordinates and their
	meassured values to file o"""
	o.write("\n\nList of Internal Coordinates and their values\n")
	for i in range(len(icl)):
		desc=modeStr(icl[i],symbs)
		if(icl[i][0]==1): #bond
			a1=icl[i][1]
			a2=icl[i][2]
			val=np.linalg.norm(geo[a2]-geo[a1])
		elif(icl[i][0]==2): #angle
			a1=icl[i][1]
			a2=icl[i][2]
			a3=icl[i][3]
			r1=geo[a1]-geo[a2]
			r2=geo[a3]-geo[a2]
			r1=r1/np.linalg.norm(r1)
			r2=r2/np.linalg.norm(r2)
			val=np.rad2deg(np.arccos(np.dot(r1,r2)))
		elif(icl[i][0]==3): # out
			a1=icl[i][1]
			a2=icl[i][2]
			a3=icl[i][3]
			a4=icl[i][4]
			r1=geo[a1]-geo[a2]
			r2=geo[a3]-geo[a2]
			r3=geo[a4]-geo[a2]
			r1 /= np.linalg.norm(r1)
			r2 /= np.linalg.norm(r2)
			r3 /= np.linalg.norm(r3)
			n1=np.cross(r1,r2)
			n2=np.cross(r3,r2)
			atmp=np.dot(n1,n2)/(np.linalg.norm(n1)*np.linalg.norm(n2))
			if(atmp>1.0):
				val=180.0-np.rad2deg(np.arccos(1.0))
			elif(atmp<-1.0):
				val=180.0-np.rad2deg(np.arccos(-1.0))
			else:
				val=180.0-np.rad2deg(np.arccos(atmp))
		elif(icl[i][0]==4): # TORS
			a1=icl[i][1]
			a2=icl[i][2]
			a3=icl[i][3]
			a4=icl[i][4]
			r1=geo[a1]-geo[a2]
			r2=geo[a2]-geo[a3]
			r3=geo[a4]-geo[a3]
			n1=np.cross(r1,r2)
			n2=np.cross(r3,r2)
			atmp=np.dot(n1,n2)/(np.linalg.norm(n1)*np.linalg.norm(n2))
			if(atmp>1.0):
				val=np.rad2deg(np.arccos(1.0))
			elif(atmp<-1.0):
				val=np.rad2deg(np.arccos(-1.0))
			else:
				val=np.rad2deg(np.arccos(atmp))
		o.write(" %4d %25s %8.3f\n"%(i+1,desc,val))
	o.write("\n")

## Core Functions ##

def VMPCore(ics,M,S,freqs):
	""" Performs a simple projection of the normal modes in M
	over the internal coordinates in S.
	Inputs:
	- ics: list of internal coordinates
	- M: displacement matrix for the vibrational modes
	- S: Wilson's S matrix for the internal coords
	- freqs: list of vibrational frequencies for pretty output
	Output:
	- o : matrix with projection of each mode (cols) over each IC (rows)
	"""
	nfreqs=len(freqs)
	nics=len(ics)
	o=np.zeros((nics,nfreqs))
	for i in range(nfreqs):
		for j in range(nics):
			o[j,i]=np.dot(S[:,j],modes[:,i])/np.linalg.norm(S[:,j])
	return(o)

def VMLDCore(ics,M,S,freqs):
	""" Performs a Linear decomposition normal modes in M
	over the internal coordinates in S, using Bayesian Ridge Regression
	with Automatic Relevance Determination.
	Inputs:
	- ics: list of internal coordinates
	- M: displacement matrix for the vibrational modes
	- S: Wilson's S matrix for the internal coords
	- freqs: list of vibrational frequencies for pretty output
	Output:
	- o : matrix with projection of each mode (cols) over each IC (rows)
	"""
	nfreqs=len(freqs)
	nics=len(ics)
	o=np.zeros((nics,nfreqs))
	ard=sklm.LinearRegression()
	for i in range(nfreqs):
		displacement=modes[:,i]
		displacement /= np.linalg.norm(displacement)
		ard.fit(S,displacement)
		for j in range(nics):
			o[j,i]=ard.coef_[j]
	return(o)

def VMARDCore(ics,M,S,freqs):
	""" Performs a linear decomposition normal modes in M
	over the internal coordinates in S, using Bayesian Ridge Regression
	with Automatic Relevance Determination.
	Inputs:
	- ics: list of internal coordinates
	- M: displacement matrix for the vibrational modes
	- S: Wilson's S matrix for the internal coords
	- freqs: list of vibrational frequencies for pretty output
	- ir: list of IR intensities for pretty output
	Output:
	- o : matrix with projection of each mode (cols) over each IC (rows)
	"""
	nfreqs=len(freqs)
	nics=len(ics)
	o=np.zeros((nics,nfreqs))
	ard=sklm.ARDRegression(compute_score=True,n_iter=3500)
	for i in range(nfreqs):
		displacement=modes[:,i]
		displacement /= np.linalg.norm(displacement)
		ard.fit(S,displacement)
		for j in range(nics):
			o[j,i]=ard.coef_[j]
	return(o)

def purifyCorrelation(of,S,il,naim,symb,modes,freqs):
	"""Removes the most correlated cols of S until naim cols"""
	o=S.copy()
	ol=il.copy()
	norig=np.shape(S)[1]
	nout=0
	of.write("\n\nPurifying S based on maximum correlation...\n")
	while(nout<(norig-naim)):
		R=np.corrcoef(o.T)**2
		scores=np.sum(np.tril(R),0)-1
		idx=list(range(np.shape(o)[1]))
		rem=idx.pop(np.argmax(scores)) #remove most correlated var
		of.write("Removed %s\n"%(modeStr(ol[rem],symb)))
		o=o[:,idx]
		t=[]
		for i in idx:
			t.append(ol[i].copy())
		ol=t.copy()
		nout += 1
	return(o,ol)

def purifyDistil(of,S,il,naim,symb,modes,freqs):
	o=S.copy()
	ol=il.copy()
	nfreqs=len(freqs)
	ncurrent=np.shape(o)[1]
	of.write("\n\nPurifying S from the least important IC's...\n")
	while(ncurrent>naim):
		imp=np.zeros((ncurrent,nfreqs))
		if(Opts['pureEngine']=='VMP'):
			imp=VMPCore(ol,modes,o,freqs)
		elif(Opts['pureEngine']=='VMLD'):
			imp=VMLDCore(ol,modes,o,freqs)
		elif(Opts['pureEngine']=='VMARD'):
			imp=VMARDCore(ol,modes,o,freqs)
		else:
			imp=VMPCore(ol,modes,o,freqs)
		imp=np.abs(imp)
		# normalize imp over cols
		for i in range(nfreqs):
			imp[:,i] /= np.linalg.norm(imp[:,i])
		imax=-1
		minval=1000000.0
		for i in range(len(ol)):
			if(np.sum(imp[i,:])<minval):
				imin=i
				minval=np.sum(imp[i,:])
		idx=list(range(np.shape(o)[1]))
		rem=idx.pop(imin) #remove most correlated var
		of.write("Removed %s\n"%(modeStr(ol[rem],symb)))
		o=o[:,idx]
		t=[]
		for i in idx:
			t.append(ol[i].copy())
		ol=t.copy()
		ncurrent=np.shape(o)[1]
	return(o,ol)

def icAutoSel(of,S,il,naim,symb,modes,freqs):
	"""Alternative selection of IC's, selecting the most important for each vib"""
	o=S.copy()
	ol=il.copy()
	nfreqs=len(freqs)
	ncurrent=np.shape(o)[1]
	of.write("\n\nSelectig the most important IC's")
	if(Opts['doARD']):
		of.write(" using VMARD...\n")
		imp=np.abs(VMARDCore(ol,modes,o,freqs))
	elif(Opts['doNMP']):
		of.write(" using VMP...\n")
		imp=np.abs(VMPCore(ol,modes,o,freqs))
	elif(Opts['doLD']):
		of.write(" using VMLD...\n")
		imp=np.abs(VMLDCore(ol,modes,o,freqs))
	else:
		of.write(" using VMP (default)...\n")
		imp=np.abs(VMPCore(ol,modes,o,freqs))
	pool=[]
	# imp is normalized over freqs
	for i in range(nfreqs):
		imp[:,i] /= np.linalg.norm(imp[:,i])
		#search for the most important contribution that is not already in the pool
		jbest=-1
		best=-10.0
		for j in range(ncurrent):
			if((imp[j,i]>best)and(j not in pool)):
				jbest=j
				best=imp[j,i]
		pool.append(jbest)
		of.write("Selected %s\n"%(modeStr(ol[jbest],symb)))
	pool.sort()
	o=o[:,pool]
	t=[]
	for i in pool:
		t.append(ol[i].copy())
	ol=t.copy()
	ncurrent=np.shape(o)[1]
	return(o,ol)

def purify(of,S,il,naim,symb,modes,freqs):
	"""Driver for the purify routines"""
	if(Opts['pureEngine']=='Corr'):
		o,ol=purifyCorrelation(of,S,il,naim,symb)
	elif(Opts['pureEngine']=='Iter'):
		o,ol=purifyDistil(of,S,il,naim,symb,modes,freqs)
	else:
		o,ol=purifyCorrelation(of,S,il,naim,symb,modes,freqs)
	return(o,ol)

def vw(X,Y):
	"""Calculates the weights of each var in X for dependent var Y
	Adapted from Jonhons, 2000, as used in the Mn(salen) PCA article"""
	print(Y.reshape(np.size(Y),1))
	M=np.concatenate((Y.reshape(np.size(Y),1),X),axis=1)
	nvar=np.shape(M.T)[1]
	R=np.corrcoef(M.T)
	rxx=R[1:,1:]
	rxy=R[1:,0]
	print("rxx:")
	print(rxx)
	print("rxy:")
	print(rxy)
	ev,evec=np.linalg.eigh(rxx)
	delta=np.eye(np.size(ev))*ev
	print('Evec')
	print(evec)
	print('delta')
	print(delta)
	lamba=np.dot(np.dot(evec,delta),evec.T)
	lambasq=lamba**2
	print("Lambda Sq")
	print(lambasq)
	beta=np.dot(np.linalg.solve(lamba,np.eye(np.shape(lamba)[0])),rxy)
	rsq=np.sum(beta**2)
	raww=np.dot(lambasq,beta)**2
	importance=(raww/rsq)*100.0
	print("Beta")
	print(beta)
	print("Rsq: ",rsq)
	print("Raw",importance)
	print("Total Importance",np.sum(importance))
	return(importance)

## Analysis Functions ##

def NMP(of,symbols,ics,M,S,freqs,ir,raman):
	""" Performs a simple projection of the normal modes in M
	over the internal coordinates in S, other inputs:
	- of: handle for the output file
	- symbols: list of atomic symbols for pretty output
	- ics: list of internal coordinates
	- M: displacement matrix for the vibrational modes
	- S: Wilson's S matrix for the internal coords
	- freqs: list of vibrational frequencies for pretty output
	- ir: list of IR intensities for pretty output
	- raman: list of Raman intensities for pretty output"""
	of.write("\n*** Analysis: Normal Mode Projection ***\n")
	nfreqs=len(freqs)
	nics=len(ics)
	if(nics>nfreqs):
		of.write("More Internal Coordinates than frequencies,\n")
		of.write("expect some (possibly unwanted) redundancy\n")
		of.write("on the results.\n")
	for i in range(nfreqs):
		of.write("\nMode %3d: %8.2f cm-1 (IR: %5.1f, Raman: %5.1f)\n"%(i+1,freqs[i],ir[i],raman[i]))
		conts=np.array([])
		natts=0
		for j in range(nics):
			proj=np.dot(S[:,j],modes[:,i])/np.linalg.norm(S[:,j])
			conts=np.concatenate((conts,[proj]))
		w=np.abs(conts)
		w=w/np.sum(w)
		local=0.0
		gw=np.zeros(5)
		gwr=np.zeros(5)
		## Set the cutoff for listed variables
		cut=0.0 # cut = all
		if(Opts['cut']=='auto'):
			cut=float(len(freqs))/float(10*len(ics))
		elif(Opts['cut']=='val'):
			cut=Opts['cutval']
		elif(Opts['cut']=='q1'):
			cut=np.percentile(w,75)
		elif(Opts['cut']=='d9'):
			cut=np.percentile(w,90)
		widx= list(np.argsort(w))
		widx.reverse()
		for j in widx:
			gw[ics[j][0]] += w[j]
			if(w[j]>=cut):
				gwr[ics[j][0]] += w[j]
				natts += 1
				local += w[j]
				of.write(" %+6.1f (%5.1f%%) %s\n"%(conts[j]*100,w[j]*100,modeStr(ics[j],symbols)))
		if(natts==0):
			of.write(" Mode too disperse!\n")
			of.write(" Largest Contribution: \n")
			j=np.argmax(w)
			of.write(" %+6.1f (%5.1f%%) %s\n"%(conts[j]*100,w[j]*100,modeStr(ics[j],symbols)))
		else:
			gwr[1:]=gwr[1:]/np.sum(gwr[1:])
		of.write(" Total Composition: %5.1f%% BOND, %5.1f%% ANGLE, %5.1f%% OUT, %5.1f%% TOR\n"%tuple(100.0*gw[1:]))
		of.write(" Rel. Composition:  %5.1f%% BOND, %5.1f%% ANGLE, %5.1f%% OUT, %5.1f%% TOR\n"%tuple(100.0*(gwr[1:])))
		of.write(" Non-Local Behaviour: %5.1f%%\n"%(100*(1-local)))
	of.write("\nEnd of Normal Mode Projection Analysis***\n\n")

def ICC(of,symbols,ics,M,S,freqs,ir,raman,cut=0.1):
	""" Estimates the contribution of each Internal coordinate in
	ics to the different vibrational modes in M. 
	Inputs:
	- of: handle for the output file
	- symbols: list of atomic symbols for pretty output
	- ics: list of internal coordinates
	- M: displacement matrix for the vibrational modes
	- S: Wilson's S matrix for the internal coords
	- freqs: list of vibrational frequencies for pretty output
	- ir: list of IR intensities for pretty output
	- raman: list of Raman intensities for pretty output"""
	of.write("\n*** Analysis: Contribution of individual Internal Coordinates ***\n")
	nfreqs=len(freqs)
	nics=len(ics)
	for i in range(nics):
		conts=np.array([])
		natts=0
		of.write("\nInternal Coordinate %3d: %s\n"%(i+1,modeStr(ics[i],symbols)))
		for j in range(nfreqs):
			proj=np.dot(modes[:,j],S[:,i])/np.linalg.norm(modes[:,j])
			conts=np.concatenate((conts,[proj]))
		w=np.abs(conts)
		w=w/np.sum(w)
		## Set the cutoff for listed variables
		cut=0.0 # cut = all
		if(Opts['cut']=='auto'):
			cut=float(len(freqs))/float(10*len(ics))
		elif(Opts['cut']=='val'):
			cut=Opts['cutval']
		elif(Opts['cut']=='q1'):
			cut=np.percentile(w,75)
		elif(Opts['cut']=='d9'):
			cut=np.percentile(w,90)
		widx= list(np.argsort(w))
		widx.reverse()
		for j in widx:
			if(w[j]>=cut):
				natts += 1
				of.write("%+6.1f (%5.1f%%) Mode %3d: %8.2f cm-1 (IR: %5.1f, Raman: %5.1f)\n"%(conts[j]*100.0,100.0*w[j],j+1,freqs[j],ir[j],raman[j]))
		if(natts==0):
			of.write(" Contribution too disperse!\n")
			of.write(" Largest Contribution: \n")
			j=np.argmax(w)
			of.write(" %+6.1f (%5.1f%%) Mode %3d: %8.2f cm-1 (IR: %5.1f, Raman: %5.1f)\n"%(conts[j]*100.0,100.0*w[j],j+1,freqs[j],ir[j],raman[j]))
	of.write("\nEnd of Internal Coordinate Contribution Analysis***\n\n")

def NMLD(of,symbols,ics,M,S,freqs,ir,raman,cut=0.1):
	""" Performs a Linear decomposition normal modes in M
	over the internal coordinates in S, using Bayesian Ridge Regression
	with Automatic Relevance Determination.
	Inputs:
	- of: handle for the output file
	- symbols: list of atomic symbols for pretty output
	- ics: list of internal coordinates
	- M: displacement matrix for the vibrational modes
	- S: Wilson's S matrix for the internal coords
	- freqs: list of vibrational frequencies for pretty output
	- ir: list of IR intensities for pretty output
	- raman: list of Raman intensities for pretty output"""
	of.write("\n*** Analysis: Normal Mode Linear Decomposition ***\n")
	nfreqs=len(freqs)
	nics=len(ics)
	if(nics>nfreqs):
		of.write("More Internal Coordinates than frequencies,\n")
		of.write("expect some (possibly unwanted) redundancy\n")
		of.write("on the results.\n")
	ard=sklm.LinearRegression()
	for i in range(nfreqs):
		of.write("\nMode %3d: %8.2f cm-1 (IR: %5.1f, Raman: %5.1f)\n"%(i+1,freqs[i],ir[i],raman[i]))
		displacement=modes[:,i]
		displacement /= np.linalg.norm(displacement)
		ard.fit(S,displacement)
		r2=np.corrcoef(displacement,ard.predict(S))[0,1]**2
		exvar=skmt.explained_variance_score(displacement,ard.predict(S))
		w=np.abs(ard.coef_)
		w=w/np.sum(w)
		natts=0
		local=0.0
		gw=np.zeros(5)
		gwr=np.zeros(5)
		## Set the cutoff for listed variables
		cut=0.0 # cut = all
		if(Opts['cut']=='auto'):
			cut=float(len(freqs))/float(10*len(ics))
		elif(Opts['cut']=='val'):
			cut=Opts['cutval']
		elif(Opts['cut']=='q1'):
			cut=np.percentile(w,75)
		elif(Opts['cut']=='d9'):
			cut=np.percentile(w,90)
		widx= list(np.argsort(w))
		widx.reverse()
		for j in widx:
			gw[ics[j][0]] += w[j]
			if(w[j]>=cut):
				gwr[ics[j][0]] += w[j]
				natts += 1
				local+=w[j]
				of.write(" %+8.4f (%5.1f%%) %s\n"%(ard.coef_[j],100*w[j],modeStr(ics[j],symbols)))
		if(natts==0):
			of.write(" Mode too disperse!\n")
			of.write(" Largest Contribution: \n")
			j=np.argmax(w)
			of.write(" %+8.4f (%5.1f%%) %s\n"%(ard.coef_[j],100*w[j],modeStr(ics[j],symbols)))
		else:
			gwr[1:]=gwr[1:]/np.sum(gwr[1:])
		of.write(" Total Composition: %5.1f%% BOND, %5.1f%% ANGLE, %5.1f%% OUT, %5.1f%% TOR\n"%tuple(100.0*gw[1:]))
		of.write(" Rel. Composition:  %5.1f%% BOND, %5.1f%% ANGLE, %5.1f%% OUT, %5.1f%% TOR\n"%tuple(100.0*(gwr[1:])))
		of.write(" R**2 = %6.4f\n"%(r2))
		of.write(" Explained Variance = %5.1f \n"%(exvar*100))
		of.write(" Non-Local Component = %5.1f \n"%((1.0-local)*100))
	of.write("\nEnd of Normal Mode Linear Decomposition Analysis***\n\n")

def NMARDD(of,symbols,ics,M,S,freqs,ir,raman,cut=0.10):
	""" Performs a linear decomposition normal modes in M
	over the internal coordinates in S, using Bayesian Ridge Regression
	with Automatic Relevance Determination.
	Inputs:
	- of: handle for the output file
	- symbols: list of atomic symbols for pretty output
	- ics: list of internal coordinates
	- M: displacement matrix for the vibrational modes
	- S: Wilson's S matrix for the internal coords
	- freqs: list of vibrational frequencies for pretty output
	- ir: list of IR intensities for pretty output
	- raman: list of Raman intensities for pretty output"""
	of.write("\n*** Analysis: Normal Mode ARD Decomposition ***\n")
	nfreqs=len(freqs)
	nics=len(ics)
	if(nics>nfreqs):
		of.write("More Internal Coordinates than frequencies,\n")
		of.write("expect some (possibly unwanted) redundancy\n")
		of.write("on the results.\n")
	ard=sklm.ARDRegression(compute_score=True,n_iter=3500)
	for i in range(nfreqs):
		of.write("\nMode %3d: %8.2f cm-1 (IR: %5.1f, Raman: %5.1f)\n"%(i+1,freqs[i],ir[i],raman[i]))
		displacement=modes[:,i]
		displacement /= np.linalg.norm(displacement)
		ard.fit(S,displacement)
		r2=np.corrcoef(displacement,ard.predict(S))[0,1]**2
		exvar=skmt.explained_variance_score(displacement,ard.predict(S))
		w=np.abs(ard.coef_)
		w=w/np.sum(w)
		natts=0
		local=0.0
		gw=np.zeros(5)
		gwr=np.zeros(5)
		## Set the cutoff for listed variables
		cut=0.0 # cut = all
		if(Opts['cut']=='auto'):
			cut=float(len(freqs))/float(10*len(ics))
		elif(Opts['cut']=='val'):
			cut=Opts['cutval']
		elif(Opts['cut']=='q1'):
			cut=np.percentile(w,75)
		elif(Opts['cut']=='d9'):
			cut=np.percentile(w,90)
		widx= list(np.argsort(w))
		widx.reverse()
		for j in widx:
			gw[ics[j][0]] += w[j]
			if(w[j]>cut):
				gwr[ics[j][0]] += w[j]
				natts += 1
				local+=w[j]
				of.write(" %+8.4f (%5.1f%%) %s\n"%(ard.coef_[j],100*w[j],modeStr(ics[j],symbols)))
		if(natts==0):
			of.write(" Mode Too Disperse! Largest Contribution:\n")
			j=np.argmax(w)
			local=w[j]
			of.write(" %+8.4f (%5.1f%%) %s\n"%(ard.coef_[j],100*w[j],modeStr(ics[j],symbols)))
		else:
			gwr[1:]=gwr[1:]/np.sum(gwr[1:])
		of.write(" Total Composition: %5.1f%% BOND, %5.1f%% ANGLE, %5.1f%% OUT, %5.1f%% TOR\n"%tuple(100.0*gw[1:]))
		of.write(" Rel. Composition:  %5.1f%% BOND, %5.1f%% ANGLE, %5.1f%% OUT, %5.1f%% TOR\n"%tuple(100.0*(gwr[1:])))
		of.write(" R**2 = %6.4f\n"%(r2))
		of.write(" Explained Variance = %5.1f \n"%(exvar*100))
		of.write(" Non-Local Component = %5.1f \n"%((1.0-local)*100))
	of.write("\nEnd of Normal Mode ARD Decomposition Analysis***\n\n")

## Main executable ##
if(__name__=='__main__'):
	# Set flags and filenames
	Linear=False # if true, internal coords will be 3N-5m instead of 3N-6
	Transition=False #if true, get the first mode and exclude the next 6 (or 5)
	if(len(sys.argv)<2):
		print("""Usage: %s [ Commands ] [ Options ] inputFile

Commands:
 --icc        Perform Internal Coordinate Contribution analysis (default)
 --noicc      Don't perform Internal Coordinate Contribution analysis
 --nmp        Perform Normal Mode Decomposition analysis.
 --nonmp      Don't perform Normal Mode Decomposition (default).
 --ld         Perform Normal Mode Linear Decomposition analysis.
 --nold       Don't perform Normal Mode Linear Decomposition (default).
 --ard        Perform Normal Mode ARD Decomposition analysis (default).
 --noard      Don't perform Normal Mode ARD Decomposition analysis (default).

Options:
 --linear     System is linear (3N-5 vibrational modes expected).
 --ts         System is a transition state 
              (first vibrational mode included as reaction coordinate).
 --mw         Use mass-weighted displacements (default).
 --rawd       Don't use mass-weighted displacements.
 --pure       Purify internal coordinates.
 --noouts     Don not generate out-of-plane internal coordinates
 --notors     Don not generate torsion internal coordinates
 --autosel    Automatic selection of internal coordinates.
 --allic      Don't purify internal coordinates (default)
 --addic FILE Read additional or user-defined internal coordinates from
              file FILE.
 --cut XX     Set the cutoff for presenting contributions:
              'auto' - Automatic selection (default)
              'all'  - All contributions are listed.
              'd9'   - Always lists the top 90%% most important contributions
              'q1'   - Always lists the top 25%% most important contributions
              X      - List only contributions above X%%
 --delta f.ff Use this value for the discete computation of S.
 --tol XX     Tolerance (in %%) for determination of atomic connectivity.
 --input XX   Input format:
              'hess'   - Orca .hess file (default).
              'g09'    - Gaussian09 output (log) file.
 --vm XX      Animate vibrational mode XX 
 --ic XX      Animate internal coordinate XX 

 Format for additional coordinates (--addic):
 - Dlain text file (extension not relevant, but .ic is recommended)
 - Lines Containing a hash (#) are ignored as comments
 - One internal coordinate per line, as a tuple of characters and numbers:
   - First Entry: B A O, or T, for bond, angle, out-of-plane or torsion, respectively
	 - Following entries: the indexes of the atoms involved, starting with 1.
   - For B, you must define 2 atoms
   - For A, you must define 3 atoms, the second being the apex of the angle
   - For B, you must define 4 atoms, the second being the central atom
   - For B, you must define 4 atoms, the first and last being the extreme of the torsion
  Examples:
    B 1 2   -> Bond between atoms 1 and 2
    A 1 4 3 -> Angle formed betweem 4-1 and 4-3

\n"""%(sys.argv[0]))
		sys.exit(1)
	arg=sys.argv[1:-1]
	n=0
	inic=False
	invm=False
	ofn='va.out'
	useric=[]
	while(n<len(arg)):
		if(arg[n]=='--linear'):
			inic=False
			invm=False
			Opts['isLinear']=True
		elif(arg[n]=='--ts'):
			inic=False
			invm=False
			Opts['isTState']=True
		elif(arg[n]=='--mw'):
			inic=False
			invm=False
			Opts['doMW']=True
		elif(arg[n]=='--rawd'):
			inic=False
			invm=False
			Opts['doMW']=False
		elif(arg[n]=='--pure'):
			inic=False
			invm=False
			Opts['doPure']=True
		elif(arg[n]=='--autosel'):
			inic=False
			invm=False
			Opts['doAutoSel']=True
		elif(arg[n]=='--noouts'):
			inic=False
			invm=False
			Opts['doOuts']=False
		elif(arg[n]=='--notors'):
			inic=False
			invm=False
			Opts['doTors']=False
		elif(arg[n]=='--allic'):
			inic=False
			invm=False
			Opts['doPure']=False
		elif(arg[n]=='--addic'):
			useric=readUserIC(arg[n+1])
			n += 1
		elif(arg[n]=='--cut'):
			inic=False
			invm=False
			if(arg[n+1]=='auto'):
				Opts['cut']='auto'
			elif(arg[n+1]=='d9'):
				Opts['cut']='d9'
			elif(arg[n+1]=='q1'):
				Opts['cut']='q1'
			elif(arg[n+1]=='all'):
				Opts['cut']='all'
			else:
				Opts['cut']='val'
				Opts['cutval']=float(arg[n+1])/100.0
			n += 1
		elif(arg[n]=='--delta'):
			inic=False
			invm=False
			Opts['delta']=float(arg[n+1])
			n += 1
		elif(arg[n]=='--tol'):
			inic=False
			invm=False
			Opts['tol']=float(arg[n+1])/100.0
			n += 1
		elif(arg[n]=='--input'):
			inic=False
			invm=False
			if(arg[n+1]=='hess'):
				Opts['input']='OrcaHess'
			if(arg[n+1]=='g09'):
				Opts['input']='G09OUT'
			else:
				print('ERROR: Input format not implemented!\n')
				sys.exit(1)
			n += 1
		elif(arg[n]=='--vm'):
			inic=False
			invm=True
		elif(arg[n]=='--ic'):
			inic=True
			invm=False
		## commands ##
		elif(arg[n]=='--icc'):
			inic=False
			invm=False
			Opts['doICC']=True
		elif(arg[n]=='--noicc'):
			inic=False
			invm=False
			Opts['doICC']=False
		elif(arg[n]=='--nmp'):
			inic=False
			invm=False
			Opts['doNMP']=True
		elif(arg[n]=='--nonmp'):
			inic=False
			invm=False
			Opts['doNMP']=False
		elif(arg[n]=='--ld'):
			inic=False
			invm=False
			Opts['doLD']=True
		elif(arg[n]=='--nold'):
			inic=False
			invm=False
			Opts['doLD']=False
		elif(arg[n]=='--ard'):
			inic=False
			invm=False
			Opts['doARD']=True
		elif(arg[n]=='--noard'):
			inic=False
			invm=False
			Opts['doARD']=False
		elif(inic):
			Opts['anic'].append(int(arg[n]))
		elif(invm):
			Opts['aniMode'].append(int(arg[n]))
		n += 1
	ifn=sys.argv[-1]
	#Check for incompatibilities
	if(Opts['doAutoSel'] and Opts['doPure']):
		print("--autosel and --purify are incompatible: autosel takes precedence!")
		Opts['doPure']=False
	#Create name/basename for output file
	if(Opts['input']=='OrcaHess'):
		ofn=ifn[:-5]
	if(Opts['input']=='G09OUT'):
		ofn=ifn[:-4]
	of=open(ofn+'.nma','w')
	of.write("""###############################################################
#                                                             #
#   vibAnalysis - version 1.01 alpha                          #
#   A set of tools to analyse vibrational modes in terms of   #
#   localized internal coordinates.                           #
#                                                             #
#   (c) Filipe Teixeira, 2017                                 #
#   filipe _dot_ teixeira _at_ fc _dot_ up _dot_ pt           #
#                                                             #
###############################################################\n""")
	# Read Geometry, Masses, Frequencies and Normal Mode Displacements
	if(Opts['input']=='OrcaHess'):
		of.write("\nOpening Hess file: %s\n\n"%(ifn))
		symbols,geometry,masses,freqs,modes,IR,Raman=readHess(ifn)
	elif(Opts['input']=='G09OUT'):
		of.write("\nOpening Gaussian09 output file: %s\n\n"%(ifn))
		symbols,geometry,masses,freqs,modes,IR,Raman=readG09out(ifn)
	# Generate quasi-redundant internal coordinated
	of.write("\nGenerating Internal Coordinates...\n")
	ic,S=makeS(symbols,geometry,useric)
	# normalize S
	if(Opts['doMW']):
	#if(False):
		natoms=len(symbols)
		massA=np.zeros(natoms*3)
		for i in range(natoms):
			massA[3*int((3*i)/3)]=masses[i]
			massA[1+3*int((3*i)/3)]=masses[i]
			massA[2+3*int((3*i)/3)]=masses[i]
		for i in range(S.shape[1]):
			S[:,i] /= np.sqrt(massA)
			#S[:,i] /= massA
	for i in range(S.shape[1]):
		S[:,i] /= np.linalg.norm(S[:,i])
	S *= Opts["delta"]
	#for i in range(S.shape[1]):
	#	print("IC %d: Norm = %f, Max= %f"%(i+1,np.linalg.norm(S[:,i]),np.max(np.abs(S[:,i]))))
	of.write("Internal Coordinates Generated: %d\n"%(len(ic)))
	# print list of internal coordinates
	of.write("""\nThis is the list of Internal Coordinates generated for
this run. Please use these indexes if you whish to animate
any one of these coordinates. If you added some user-defined
coordinates, please be sure to re-run this program with the
same added coordinates.\n""")
	punchLIC(of,ic,symbols,geometry)
	#of.write("Internal Coordinates Expected:  %d\n"%(len(freqs)))
	#if(len(ic)>len(freqs)):
	#	of.write("Expect some redundancy in the internal coordinate decomposition!\n")
	## If MW, mass-weight the normal modes
	if(Opts['doMW']):
		of.write("\nMass-weighting the atomic displacements...\n\n")
		natoms=len(symbols)
		massA=np.zeros(natoms*3)
		for i in range(natoms):
			massA[3*int((3*i)/3)]=masses[i]
			massA[1+3*int((3*i)/3)]=masses[i]
			massA[2+3*int((3*i)/3)]=masses[i]
		for i in range(len(freqs)):
			modes[:,i]=modes[:,i]*np.sqrt(massA)
			modes[:,i] /= np.linalg.norm(modes[:,i])
	#for i in range(modes.shape[1]):
	#	print("VM %d: Norm = %f, Max= %f"%(i+1,np.linalg.norm(modes[:,i]),np.max(np.abs(modes[:,i]))))
	## Animate modes?
	if(len(Opts['aniMode'])>0):
		of.write("\n")
		for mode in Opts['aniMode']:
			tfn="%s.v%03d.xyz"%(ofn,mode)
			of.write("Animating mode %d to file: %s\n"%(mode,tfn))
			animateMode(tfn,symbols,geometry,modes[:,mode-1])
		of.write("\n")
	if(len(Opts['anic'])>0):
		of.write("\n")
		for icidx in Opts['anic']:
			tfn="%s.i%03d.xyz"%(ofn,icidx)
			of.write("Animating internal coordinate %d to file: %s\n"%(icidx,tfn))
			animateMode(tfn,symbols,geometry,S[:,icidx-1])
		of.write("\n")
	## If pure, purify IC ...
	if(Opts['doPure']):
		of.write("\nPurifying the set of Internal Coordinates...\n\n")
		S,ic=purify(of,S,ic,len(freqs),symbols,modes,freqs)
		punchLIC(of,ic,symbols,geometry)
	# ... or select the most valuable ones
	#if(Opts['doAutoSel']):
	#	of.write("\nAutomatic Selection of Internal Coordinates...\n\n")
	#	S,ic=icAutoSel(of,S,ic,len(freqs),symbols,modes,freqs)
	#	punchLIC(of,ic,symbols,geometry)
	## Do the analysis
	if(Opts['doICC']):
		ICC(of,symbols,ic,modes,S,freqs,IR,Raman)
	if(Opts['doNMP']):
		NMP(of,symbols,ic,modes,S,freqs,IR,Raman)
	if(Opts['doLD']):
		NMLD(of,symbols,ic,modes,S,freqs,IR,Raman)
	if(Opts['doARD']):
		NMARDD(of,symbols,ic,modes,S,freqs,IR,Raman)
	## Clean up
	of.close()



